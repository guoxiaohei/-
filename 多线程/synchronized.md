-  synchronized

  - 线程安全问题的主要诱因：

    存在共享数据（也称临界资源）

    存在多条线程共同操作这些共享数据

  - 解决问题的根本方法：

    同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作

  - 互斥锁的特性

    互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块(复合操作)进行访问。互斥性也称为操作的原子性。

    可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。

    synchronized锁的不是代码，而是对象。
    
  - 获取对象锁的两种方法：
  
    1. 同步代码块（synchronized(this),synchronized(类实例对象)），锁是小括号中的实例对象
    2. 同步非静态方法（synchronized method），锁是当前对象的实例对象
  
  - 获取类锁的两种方法：（每个类只有一个类锁）
  
    1. 同步代码块（synchronized(类.class)），锁是小括号中的类对象（Class对象）
    2. 同步静态方法（synchronized static method），锁是当前对象的类对象（Class对象）
  
  - 对象锁和类锁的总结：
  
    1. 有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块；
    2. 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步代码块的线程会被阻塞；
    3. 若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞
    4. 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步方法的线程会被阻塞，反之亦然
    5. 同一个类的不同对象的对象锁互不干扰
    6. 类锁由于也是一种特殊的对象锁，因此表现和上述1,2,3,4一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的
    7. 类锁和对象锁互不干扰
  
  - 自旋锁与自适应自旋锁：
  
    - 自旋锁（使用PreBlockSpin参数更改）
  
      ​	许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行忙循环等待锁的释放，不让出CPU
  
      ​	缺点：若锁被其他线程长时间占用，会带来许多性能上的开销
  
    - 自适应自旋锁（JAVA6开始引入）
  
      ​	自旋次数不再固定
  
      ​	由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。
  
  - 锁消除：更彻底的优化,虚拟机在JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁，可以节省系统性能。
  
  - 锁粗化：通过扩大加锁的范围，避免反复加锁和解锁
  
  - synchronized的四种状态：
  
    ​	锁膨胀方向：无锁、偏向锁、轻量级锁、重量级锁
  
    | 锁       | 优点                                                         | 缺点                                                         | 使用场景                                         |
    | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------ |
    | 偏向锁   | 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗               | 只有一个线程访问同步块或者同步方法的场景         |
    | 轻量级锁 | 竞争的线程不会阻塞，提高了响应速度                           | 若线程长时间抢不到锁，自旋会消耗CPU性能                      | 线程交替执行同步块或者同步方法的场景             |
    | 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗 | 追求吞吐量，同步块或者同步方法执行时间较长的场景 |
  
  - Mark Word内存结构（32bit）：默认存储对象的hashCode，分代年龄，锁类型，锁标志位等信息
  
    ![1556175968776](http://weiguo-1303915920.cos.ap-nanjing.myqcloud.com/747dd52dfa52219d95da0cd21e4e25ba.png)
  
  - Monitor：（管程，一种同步机制）
  
    ​	synchronzied 需要关联一个对象，而这个对象就是 monitor object，Java 语言中的 java.lang.Object 类，便是满足这个要求的对象，任何一个 Java 对象都可以作为 monitor 机制的 monitor object。
  
    ​	java.lang.Object 类定义了 wait()，notify()，notifyAll() 方法，这些方法的具体实现，依赖于一个叫 ObjectMonitor 模式的实现，这是 JVM 内部基于 C++ 实现的一套机制。源码中，owner记录当前获取到锁的线程，EntrySet表示锁池，WaitSet表示等待池。