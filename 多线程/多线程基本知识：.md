-  #### 进程与线程的区别：

1. 进程是资源分配的最小单位，线程是CPU调度的最小单位
2. 线程不能看做独立应用，而进程可以看做独立应用
3. 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径
4. 线程没有独立的地址空间，多进程的程序比多线程程序健壮
5. 进程的切换比线程的切换开销大

- #### java进程和线程的关系：

1. java对操作系统提供的功能进行封装，包括进程和线程
2. 运行一个程序会产生一个进程，进程包含至少一个线程
3. 每个进程对应一个JVM实例，多个线程共享JVM里的堆
4. Java采用单线程编程模型，程序会自动创建主线程
5. 主线程可以创建子线程，原则上要后于子线程完成执行

- #### 获取当前线程的name：

  Thread.currentThread().getName()

- #### Thread中start方法与run方法的区别：

  1. 调用start()方法会创建一个新的子线程并启动(本地方法：JVM_StartThread)
  2. run()方法只是Thread的一个普通方法的调用

- #### Thread和Runnable的关系：

  1. Thread是实现了Runnable接口的类，使得run支持多线程
  2. 因为Java类的单一继承原则，推荐多使用Runnable接口

- #### 如何实现处理线程的返回值

  1. 主线程等待法
  2. 实用Thread的join()方法阻塞当前线程以等待子线程处理完毕
  3. 通过Callable接口实现：通过FutureTask或者线程池获取

- #### 线程的状态：

  1. 新建（New）：创建后尚未启动的线程的状态
  2. 运行（Runnable）：包含Running和Ready状态
  3. 无限期等待（Waiting）：不会被分配CPU执行时间，需要显式被唤醒
  4. 限期等待（Timed Waiting）：在一定时间后由系统自动唤醒
  5. 阻塞（Blocked）：等待获取排它锁
  6. 结束（Terminated）：已终止线程的状态，线程已经结束执行

- #### sleep和wait的区别

  1. sleep是Thread类的方法，wait是Object类中定义的方法
  2. sleep()方法可以在任何地方使用
  3. wait()方法只能在synchronized方法或者synchronized块中使用

  - 最主要的本质区别：

    Thread.sleep只会让出CPU，不会导致锁行为的改变

    Object.wait不仅让出CPU，还会释放已经占有的同步资源锁

- #### notify和notifyAll的区别：

  - 两个概念：锁池与等待池
    1. 锁池：假设线程A已经拥有了某个对象（不是类）的锁，而其他线程B、C想要调用这个对象的某个synchronized方法（或者块），由于B、C线程在进入对象的synchronized方法或者（块）之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正在被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池。
    2. 等待池：假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁。
  - 区别：notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会

- #### yield

  - 概念：当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示。(对锁的行为不会有影响)

- #### 如何中断线程

  1. 已经抛弃的方法：通过调用线程实例对象的stop()方法停止线程（线程不安全）；suspend()和resume()方法同理。

  2. 现在使用的方法：

     调用interrupt(),通知线程应该中断了。

     如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常；如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。   

     需要被调用的线程配合中断。



 







 





  

