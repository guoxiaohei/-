## 持久化之RDB

RDB（Redis DataBase）

### 是什么

- 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里
- Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。

> Fork
>
> Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程

- rdb 保存的是dump.rdb文件

- 相关配置在配置文件的位置 - 在redis.conf搜寻`### SNAPSHOTTING ###`

  ![image-20201104090144235](http://weiguo-1303915920.cos.ap-nanjing.myqcloud.com/da36024bcbb675075032ba53f0e90f5f.png)

### 如何触发RDB快照

- 配置文件中默认的快照配置(备份文件位于bin文件夹下)

  ```
  dbfilename dump.rdb#设置备份文件名为dump.rdb
  ```

  - 冷拷贝后重新使用
    - 可以cp dump.rdb dump_new.rdb

- 命令save或者是bgsave

  - Save：save时只管保存，其它不管，全部阻塞
  - BGSAVE：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间

- 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义

### 如何恢复

- 将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可
- `CONFIG GET dir`获取目录

### 优势与劣势

- 优势
  - 适合大规模的数据恢复
  - 对数据完整性和一致性要求不高
- 劣势
  - 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就 会丢失最后一次快照后的所有修改
  - Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑

### 如何停止

动态所有停止RDB保存规则的方法：`redis-cli config set save ""`

### 小结

![img](http://weiguo-1303915920.cos.ap-nanjing.myqcloud.com/26e2f99109234ae2ed85fbdb456a97a0)

- RDB是一个非常紧凑的文件。
- RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他I0操作，所以RDB持久化方式可以最大化redis的性能。
- 与AOF相比，在恢复大的数据集的时候，RDB方式会更快一一些。
- 数据丢失风险大。
- RDB需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候fork的过程是非常耗时的，可能会导致Redis在一些毫秒级不能回应客户端请求。

## 持久化之AOF

AOF（Append Only File）

### 是什么

以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作

### AOF配置

- 相关配置在配置文件的位置 - 在redis.conf搜寻`### APPEND ONLY MODE ###`
- aof保存的是appendonly.aof文件（在配置文件可修改文件名）

### AOF启动/修复/恢复

- 正常恢复
  - 启动：设置Yes
    - 修改默认的appendonly no，改为yes
  - 将有数据的aof文件复制一份保存到对应目录(config get dir)
  - 恢复：重启redis然后重新加载
- 异常恢复
  - 启动：设置Yes
    - 修改默认的appendonly no，改为yes
  - 备份被写坏的AOF文件
  - 修复：
    - Redis-check-aof --fix进行修复
  - 恢复：重启redis然后重新加载

### rewrite

- 是什么：
  
  - AOF采用文件追加方式，文件会越来越大。为避免出现此种情况，新增了重写机制， 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集。可以使用命令bgrewriteaof
- 重写原理
  
  - AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)， 遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件， 而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似
- 触发机制
  
  - Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发
  
    ![image-20201109095031467](http://weiguo-1303915920.cos.ap-nanjing.myqcloud.com/c6816d1b8b2a024ffe1c7500f2e0f247.png)

### 优势与劣势

- 优势
  - 每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好
  - 每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失
  - 不同步：appendfsync no 从不同步
- 劣势
  - 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb
  - Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同

### 小结

![img](http://weiguo-1303915920.cos.ap-nanjing.myqcloud.com/17d2ea15e8436502a3d9474a762277d2)

- AOF文件时一个只进行追加的日志文件
- Redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写
- AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此AOF文件的内容非常容易被人读懂，对文件进行分析也很轻松
- 对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积
- 根据所使用的fsync 策略，AOF的速度可能会慢于RDB

## 

## 两种方式总结：

- RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储
- 只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。
- 同时开启两种持久化方式：
  - 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
  - RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，建议RDB留着作为一个容错的手段

![image-20201109104641033](http://weiguo-1303915920.cos.ap-nanjing.myqcloud.com/fd8a4a73856292f2f3a8423a2c3a3a21.png)